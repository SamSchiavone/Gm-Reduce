//AttachSpec("../endomorphisms/endomorphisms/magma/spec");
//import "../endomorphisms/endomorphisms/magma/puiseux/FractionalCRT.m": RandomSplitPrime;
// have to change if endomorphisms repo is elsewhere
//AttachSpec("../Belyi/Code/spec"); // have to change if Belyi repo is elsewhere
// includes intrinsic S3Action(tau, phi)

intrinsic ReduceRationalFunction(X::Crv, phi::FldFunFracSchElt, P::RngOrdIdl) -> Any
  {Given a Belyi map phi defined on a curve X and a prime ideal of the field of definition of X, return the reductions of X and phi mod P}

  // make curve over finite field
  KX := Parent(phi);
  K := BaseRing(X);
  OK := Integers(K);
  FF, res_mp := ResidueClassField(P);
  X_FF := Reduction(X, P);
  X_FF := Curve(X_FF);
  KX_FF := FunctionField(X_FF);

  AX := CoordinateRing(X);
  N_gens := #GeneratorsSequence(AX) - 1; // number of generators for the function field
  KX_gens := [];
  KX_FF_gens := [];
  for i := 1 to N_gens do
    Append(~KX_gens, KX.i);
    Append(~KX_FF_gens, KX_FF.i);
  end for;

  // reduce map
  num_cs, num_mons := CoefficientsAndMonomials(Numerator(phi));
  num_pows := [Exponents(el) : el in num_mons];
  den_cs, den_mons := CoefficientsAndMonomials(Denominator(phi));
  den_pows := [Exponents(el) : el in den_mons];
  phi_FF_num := KX_FF!0;
  for i := 1 to #num_cs do
    phi_FF_num +:= res_mp(num_cs[i])*&*[KX_FF.j^num_pows[i][j] : j in [1..N_gens]];
  end for;
  phi_FF_den := KX_FF!0;
  for i := 1 to #den_cs do
    phi_FF_den +:= res_mp(den_cs[i])*&*[KX_FF.j^den_pows[i][j] : j in [1..N_gens]];
  end for;
  return X_FF, phi_FF_num/phi_FF_den;
end intrinsic;

// copied form endomorphisms b/c EquationOrder is causing problems

function ReduceConstantSplit(x, h)
  return h(x);
end function;

function ReducePolynomialSplit(f, h)
  FF := Codomain(h); R_red := PolynomialRing(FF, Rank(Parent(f)));
  f_red := &+[ ReduceConstantSplit(MonomialCoefficient(f, mon), h) * Monomial(R_red, Exponents(mon)) : mon in Monomials(f) ];
  // Magma subtlety: we have to coerce to a univariate polynomial ring instead of
  // a multivariate ring in one variable
  if Rank(Parent(f)) eq 1 then
      return PolynomialRing(FF) ! f_red;
  end if;
  return f_red;
end function;

function RandomSplitPrime(f, B)
  /*
   * Input:  A polynomial f over K and a positive integer B
   * Output: A totally split prime in K of size roughly 2^B
   *         that stays totally split in the extension generated by f
   */

  K := BaseRing(Parent(f));
  OK := Integers(K);

  while true do
      repeat p := RandomPrime(B : Proof := false); until p^2 ge B;
      FF := FiniteField(p);

      if Type(K) eq FldRat then
          test := true; rt := 1;
      else
          test, rt := HasRoot(MinimalPolynomial(K.1, Rationals()), FF);
      end if;

      if test then
          pr := ideal<OK | [ p, (OK ! K.1) - (OK ! (Integers() ! rt)) ]>;
          /* This calculation costs quite some time */
          FF, h := ResidueClassField(pr);
          f_red := ReducePolynomialSplit(f, h);
          /* We demand full splitting because in the end we have to work with all
           * branches while iterating, and that is better over a prime field */
          if #Roots(f_red) eq Degree(f_red) then
              return pr, h;
          end if;
      end if;
  end while;
end function;

intrinsic PrimeForReduction(phi::FldFunFracSchElt, xs : PrimeBound := 0) -> Any
  {Get prime of size 2^PrimeBound of the base field of parent of phi that doesn't divide any denominators.}

  KX := Parent(phi);
  X := Curve(KX);
  K := BaseRing(X);
  OK := Integers(K);
  R<t> := PolynomialRing(K);
  if PrimeBound eq 0 then
    PrimeBound := 32;
  end if;

  P := RandomSplitPrime(t,PrimeBound);
  // check that P doesn't divide denominators
  dens := [];
  for fcn in xs cat [phi] do
    for el in Coefficients(Numerator(fcn)) do
      Append(~dens, Denominator(el));
    end for;
    for el in Coefficients(Denominator(fcn)) do
      Append(~dens, Denominator(el));
    end for;
  end for;
  I := ideal< OK | dens >;
  assert GCD(P,I) eq 1*OK;
  return P;
end intrinsic;

intrinsic SortSmallFunctions(phi::FldFunFracSchElt, xs::SeqEnum : Prime := 0, PrimeBound := 0) -> SeqEnum
  {Given a list xs of functions, compute the size of the monomial support of the resulting curve mod a prime. Return the list of functions sorted by this size.}

  KX := Parent(phi);
  X := Curve(KX);
  if PrimeBound eq 0 then
    PrimeBound := 32;
  end if;
  if Prime eq 0 then
    P := PrimeForReduction(phi, xs : PrimeBound := PrimeBound);
  else
    P := Prime;
  end if;
  //printf "prime used P = %o\n", P;

  // reduce small functions by P
  X_FF, phi_FF := ReduceRationalFunction(X, phi, P);
  xs_FF := [];
  for el in xs do
    _, x_FF := ReduceRationalFunction(X, el, P);
    Append(~xs_FF, x_FF);
  end for;
  Nmons := [];
  for i := 1 to #xs do
    x_op := xs[i];
    x_op_FF := xs_FF[i];
    //print "computing model over finite field";
    F_res_FF := PlaneModel(phi_FF, x_op_FF);
    mons_FF := Monomials(F_res_FF);
    Append(~Nmons, #mons_FF);
    //printf "%o monomials, max degree = %o\n", #mons_FF, Max([Degree(el) : el in mons_FF]);
  end for;
  xs_sorted := xs;
  ParallelSort(~Nmons, ~xs_sorted);
  return xs_sorted;
end intrinsic;
