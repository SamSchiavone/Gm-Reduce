//AttachSpec("../Belyi/Code/spec"); // have to change if Belyi repo is elsewhere
SetClassGroupBounds("GRH");

// TODO: just import from Belyi; Gm-Reduce should output f and scalar a
intrinsic BelyiMapSanityCheck(sigma::SeqEnum[GrpPermElt], f::RngMPolElt : lax := false) -> Any
  {Does a basic check to see if the candidate is plausible. If lax is set to true, then work in the category of lax Belyi maps.}
  // make curve and function field to compute divisors
  X := Curve(AffineSpace(Parent(f)), f);
  KX<t,x> := FunctionField(X);
  // compute third ramification value (not nec 1)
  rambool, a := ComputeThirdRamificationValue(f);
  if rambool then
    L := Parent(a);
    assert L eq BaseRing(Parent(f));
  else
    a := 1;
  end if;

  supp, ramdeg := Support(Divisor(t));
  supp1, ramdeg1 := Support(Divisor(t-a));
  // print ramdeg;
  // print ramdeg1;
  cyc := [];
  for i := 1 to 3 do
    if i eq 1 then
      cyci := Sort([<ramdeg[i], Degree(supp[i])> : i in [1..#supp] | ramdeg[i] gt 0]);
    elif i eq 2 then
      cyci := Sort([<ramdeg1[i], Degree(supp1[i])> : i in [1..#supp1] | ramdeg1[i] gt 0]);
    else
      cyci := Sort([<Abs(ramdeg[i]), Degree(supp[i])> : i in [1..#supp] | ramdeg[i] lt 0]);
    end if;
    // Clean up in case points split
    j := 1;
    while j lt #cyci do
      if cyci[j][1] eq cyci[j+1][1] then
        cyci := cyci[1..j-1] cat [<cyci[j][1], cyci[j][2]+cyci[j+1][2]>] cat cyci[j+2..#cyci];
      else
        j +:= 1;
      end if;
    end while;
    Append(~cyc, cyci);
  end for;
  map_structure := cyc;
  sigma_structure := [Sort(CycleStructure(s)) : s in sigma];
  if lax eq false then
    return (map_structure eq sigma_structure);
  else
    if map_structure eq sigma_structure then
      return true, Sym(3)!1;
    else
      lax_equivalent := false;
      lax_permutation := Sym(3)!1;
      for s in Sym(3) do
        lax_sigma := S3Action(s, sigma);
        lax_sigma_structure := [Sort(CycleStructure(t)) : t in lax_sigma];
        if map_structure eq lax_sigma_structure then
          lax_equivalent := true;
          lax_permutation := Sym(3)!s;
        end if;
      end for;
      return lax_equivalent, lax_permutation;
    end if;
  end if;
end intrinsic;

intrinsic SmallFunctions(Qs::SeqEnum[PlcCrvElt], d::RngIntElt) -> SeqEnum
  {Given a sequence of points Qs, return functions supported on Qs of degree <= d}
  // Qs, points which are "small"
  // d, a degree bound;
  // Output: functions supported on {Qs} of degree <= d

  //The "small" points are the support of phi, phi-1.
  //sort "small" points by degree
  Qs := Sort(Qs, func<Q,R | Degree(Q)-Degree(R)>);
  Ds := [];
  QDs := [Divisor(Q) : Q in Qs]; //Make the points into divisors
  newDs := [Universe(QDs) | 0];

  //add divisors so that degree is <= d and collect in Ds
  while #newDs ne 0 do
    frontierDs := [];
    for newD in newDs do
      dnewD := Degree(newD);
      for RD in QDs do
        if Degree(RD) + dnewD le d then
          Append(~Ds, RD + newD);
          Append(~frontierDs, RD + newD);
        end if;
      end for;
    end for;
    newDs := frontierDs;
  end while;
  Ds:=Setseq(Set(Ds));
  if #Ds eq 0 then return []; end if;

  xs := [];
  divisorsSeen := [Universe(Ds) | 0];
  for Dden in Ds do
    for Dnum in Ds do
      D := Dden-Dnum;
      // if Degree(D) ne 0 then continue; end if;
      if D eq Parent(D)!0 then continue; end if;
      RR, mRR := RiemannRochSpace(D);
      if Dimension(RR) eq 1 then
        x := mRR(RR.1);
        divx := Divisor(x);
        // yeah yeah, we know a lot about the divisor of x, but
        // it may have an extra zero (or zeros!)
        if divx notin divisorsSeen then
          Append(~xs, x);
          Append(~divisorsSeen, divx);
        end if;
      end if;
    end for;
  end for;
  //looks like every x appears twice
  return Setseq(Set(xs));
  //functions supported on the points of small degree as
  //generated by the Riemann Roch space
end intrinsic;


intrinsic SmallFunctionsExactDegree(Qs::SeqEnum[PlcCrvElt], d::RngIntElt) -> SeqEnum
  {Given a sequence of points Qs, return functions supported on Qs of exact degree d}
  if d eq 1 then
    return SmallFunctions(Qs,d);
  else
    sfd:=SmallFunctions(Qs,d);
    sfd1 := SmallFunctions(Qs,d-1);
    return [ s : s in sfd | s notin sfd1 ];
  end if;
end intrinsic;

intrinsic model(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {Given a Belyi map phi and a rational function x_op, find a plane model for the curve with phi and x_op as coordinates}
  //add 1/phi etc in here.
  fu := MinimalPolynomial(phi);
  fv := MinimalPolynomial(x_op);
  K := BaseRing(BaseRing(Parent(phi)));
  Kuvz<vz,uz,z> := PolynomialRing(K, 3);
  _<vf,uf,zf> := FieldOfFractions(Kuvz);

  fues := Eltseq(fu);
  fves := Eltseq(fv);
  fu := Numerator(&+[Evaluate(fues[i],zf)*uf^(i-1) : i in [1..#fues]]);
  fv := Numerator(&+[Evaluate(fves[i],zf)*vf^(i-1) : i in [1..#fves]]);

  fuv := Resultant(fu,fv,z);
  //groebner basis? 1/phi here etc
  /*
    _<u> := PolynomialRing(K);
    _<v> := PolynomialRing(Parent(u));
    cuv := Coefficients(fuv);
    muv := Monomials(fuv);
    return &+[cuv[i]*Evaluate(muv[i],[v,u,0]) : i in [1..#cuv]];
  */
  // determine which factor of the result has roots x_op and phi
  
  Kphi := Parent(phi);
  Kx_op := Parent(x_op);
  X := Curve(Kphi);
  if Genus(X) eq 0 then
    iso_x := hom< Kx_op -> Kphi | [Kphi.1]>;
  else
    iso_x := hom< Kx_op -> Kphi | [Kphi.1, Kphi.2]>;
  end if;

  fuvFact := Factorization(fuv);
  if #fuvFact gt 1 then
    for j := 1 to #fuvFact do
      if Evaluate(fuvFact[j][1], [iso_x(x_op),phi,0]) eq 0 then
        fuv := fuvFact[j][1];
        assert &and[Evaluate(fuvFact[k][1], [iso_x(x_op),phi,0]) ne 0 : k in [j+1..#fuvFact]];
      end if;
    end for;
  else
    fuv:=fuvFact[1][1];
  end if;
  //_<u,v> := PolynomialRing(K,2);
  //return Evaluate(fuv,[v,u,0]);
  _<t,x> := PolynomialRing(K,2);
  f_plane:=Evaluate(fuv,[x,t,0]);
  //f_univ:=MultivariateToUnivariate(f_unit);
  //f_display:=PolynomialToFactoredString(f_univ);
  return f_plane;
  //S3orbit, 1-t, lookup in Belyi/code/belyi_main/S3Orbit()
  //x=v, t=u
end intrinsic;

intrinsic ReducedEquation(f::RngMPolElt) -> RngMPolElt
  {Given a mutlivariate polynomial return it's reduction}
  f_padic := reducemodel_padic(f);
  f_unit := reducemodel_units(f);
  return f_unit;
end intrinsic;


intrinsic ReducedModel(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {}
  f_plane := model(phi,x_op);
  f_padic := reducemodel_padic(f_plane);
  f_unit := reducemodel_units(f_padic);
  return f_unit;
end intrinsic;


intrinsic ReducedModelsS3Orbit(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {}
  /*
    phis := S3Orbit(phi);
    return [* ReducedModel(el,x_op) : el in phis *];
  */
  f := ReducedModel(phi, x_op);
  return S3Orbit(f);
end intrinsic;

intrinsic ReducedModelS3Orbit(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {find a reduced model of phi w.r.t. to x_op, compute the S3-orbit and return the smallest one}
  s3_orbit:=ReducedModelsS3Orbit(phi,x_op);
  s3_size:= [ < #Sprint(g), g > : g in s3_orbit ];
  Sort(~s3_size);
  return s3_size[1,2];
end intrinsic;

intrinsic ComputeThirdRamificationValue(f::RngMPolElt) -> Any
  {Given a polynomial f(t,x) defining a plane curve where t is a 3-point branched cover ramified over 0, oo, and s, return s}
  C := Curve(AffineSpace(Parent(f)), f);
  KC<t,x> := FunctionField(C);
  ram_up := Support(Divisor(Differential(t)));
  ram_down := [*Evaluate(t, el) : el in ram_up*];
  ram_other := [el : el in ram_down | el ne 0 and el cmpne Infinity()];
  ram_other := Setseq(Set(ram_other));
  assert #ram_other in [0,1];
  if #ram_other eq 1 then
    a1:=BaseField(C)!ram_other[1];
    return true, a1;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic S3Action(tau::GrpPermElt, f::RngMPolElt) -> RngMPolElt
  {}
  S := Sym(3);
  assert Parent(tau) eq S;

  R<t,x> := Parent(f);
  bool, a := ComputeThirdRamificationValue(f);
  if bool then
    L := Parent(a);
    assert L eq BaseRing(Parent(f));
  else
    a := 1;
  end if;
  //RL<t,x> := ChangeRing(R,L);
  // TODO: fix this when only ramified above 0, oo
  if tau eq S!(1,2) then
    //return 1-phi;
    t_ev := a-t;
  elif tau eq S!(1,3) then
    //return 1/phi;
    t_ev := a^2/t;
  elif tau eq S!(2,3) then
    //return phi/(phi-1);
    t_ev := a - a^2/(a-t);
  elif tau eq S!(1,2,3) then // are these two backwards?
    //return 1-1/phi;
    t_ev := a - a^2/t;
  elif tau eq S!(1,3,2) then // are these two backwards? or right- vs left action?
    //return 1/(1-phi);
    t_ev := a^2/(a-t);
  else
    t_ev := t;
  end if;
  return Numerator(Evaluate(f, [t_ev,x])); // need to re-integralize at the end?
end intrinsic;

intrinsic S3Orbit(f::RngMPolElt) -> SeqEnum
  {}
  return [ Parent(f)!S3Action(el, f) : el in Sym(3) ];
end intrinsic;

intrinsic AllReducedEquations(phi::FldFunFracSchElt : effort := 30, degree:= 3) -> SeqEnum
  {}
  RsandPs := Support(Divisor(phi));
  RsandQs := Support(Divisor(phi-1));
  PsQsRs := SetToSequence(SequenceToSet(RsandPs cat RsandQs));

  xs := SmallFunctions(PsQsRs, degree);
  xs_ts_Fs_sorted := SortSmallFunctions(phi,xs : effort := effort);
  reduced_models := [];
  for tup in xs_ts_Fs_sorted do
    t, x, F := Explode(tup);
    fred := ReducedModel(t, x);
    // printf "t = %o,\nx = %o,\nreduced model = %o\n\n", t, x, fred;
    Append(~reduced_models, <#Sprint(fred), t, x, fred>);
  end for;
  Sort(~reduced_models);
  // return reduced_models;
  return [reddat[4] : reddat in reduced_models];
end intrinsic;


//add intrinsic to loop over small functions and output ReduceModel();

intrinsic PlaneModel(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {}
  return model(phi,x_op);
end intrinsic;

function PlaneModelGroebner(phi, x_op)
  //{Given a Belyi map phi, return a plane model for its domain such that t is the Belyi map}
  KC := Parent(phi);
  C := Curve(KC);
  K := BaseRing(C);
  nu := K.1;
  phi0 := Numerator(phi);
  phioo := Denominator(phi);
  x_op0 := Numerator(x_op);
  x_opoo := Denominator(x_op);
  if Genus(C) eq 0 then // defined on PP^1, so no curve equation
    R<X,Phi,X_op,u,v> := PolynomialRing(K,5);
    h := hom< KC -> R | [X]>;
    I := ideal< R | h(phioo)*Phi - h(phi0), h(x_opoo)*X_op - h(x_op0), v*h(phioo) - 1, u*h(x_opoo) - 1>; // need last equations to avoid points where phioo = 0
    // eliminate v to obtain plane equation
    basis := Basis(EliminationIdeal(I,{X_op,Phi}));
    assert #basis eq 1;
    new_eqn := basis[1];
    S<x,t> := PolynomialRing(K,2);
    h_plane := hom< Parent(new_eqn) -> S | [x,t,0,0,0] >;
  else // so the curve actually has an equation
    KC<x,y> := KC;
    R<X,Y,Phi,X_op,u,v> := PolynomialRing(K,6);
    h := hom< KC -> R | [X,Y]>;
    curve_eqn := DefiningEquation(AffinePatch(C,1));
    h_curve := hom< Parent(curve_eqn) -> R | [X,Y] >;
    // need last equation to avoid points where phioo = 0
    I := ideal< R | h_curve(curve_eqn), h(phioo)*Phi - h(phi0), h(x_opoo)*X_op - h(x_op0), v*h(phioo) - 1, u*h(x_opoo) - 1>; // need last equations to avoid points where phioo = 0
    // eliminate X and v to obtain plane equation
    basis := Basis(EliminationIdeal(I,{X_op,Phi}));
    assert #basis eq 1;
    new_eqn := basis[1];
    printf "new equation = %o\n", new_eqn;
    S<x,t> := PolynomialRing(K,2);
    h_plane := hom< Parent(new_eqn) -> S | [0,0,t,x,0,0] >;
    //h_plane := hom< Parent(new_eqn) -> S | X_op :-> x, Phi :-> t, X :-> 0, Y :-> 0, u :-> 0, v :-> 0 >;
  end if;
  return h_plane(new_eqn);
end function;

intrinsic CoefficientValuationsSum(f::., pp::.) -> Any
  {}
  return &+[ Valuation(a,pp) : a in Coefficients(f) ], [ Valuation(a,pp) : a in Coefficients(f) ];
end intrinsic;

intrinsic BelyiObjectiveFunction(fuv::RngMPolElt) -> RngMPolElt
  {Given a polynomial or rational function fuv in 2 variables, return...?} // TODO: finish doc string
  K := BaseRing(Parent(fuv));
  u := Parent(fuv).1;
  v := Parent(fuv).2;
  Rx3<x1,x2,x3>:=PolynomialRing(Rationals(),3);
  mexps := [ Exponents(m) : m in Monomials(fuv) ];
  coefs:=Coefficients(fuv);
  assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
  return (&+[ m[1] : m in mexps])*x1 + (&+[ m[2] : m in mexps])*x2 + #mexps*x3;
end intrinsic;

intrinsic MultivariateToUnivariate(f::RngMPolElt) -> RngUPolElt
  {turns an element f in K[x,t] into an element K[x][t]}

  fstring:=Sprint(f);
  K<nu1> := BaseRing(Parent(f));
  Kx<x>:=PolynomialRing(K);
  Kxt<t>:=PolynomialRing(Kx);
  return eval(fstring);
end intrinsic;

intrinsic MonicToIntegral(f::RngUPolElt : Minkowski := true) -> Any
  {scale the monic univariate polynomial to be integral}
  assert IsMonic(f);
  K:=BaseRing(Parent(f));
  ZK:=Integers(K);
  coefs:=[ a : a in Coefficients(f) | a ne 0 ];

  aa := ideal<ZK | coefs>^-1;
  aprin, a := IsPrincipal(aa);
  if aprin eq false then
    a:=IdealShortVectorsProcess(aa, 0, 2: Minkowski:=Minkowski)[1];
  end if;
  f_new:=f*a;

  return f_new, a;
end intrinsic;

intrinsic PolynomialToFactoredString(f::RngUPolElt) -> MonStgElt
  {factorise the polynomial f and return it as a string. Needs to be a multivariate polynomial in K[x][t]}

  coefs:=Coefficients(f);
  mon:=Monomials(f);
  str:="";
  for j in [1..#coefs] do
    if j ne 1 then
      str:=str cat " + ";
    end if;
    a:=LeadingCoefficient(coefs[j]);
    fac:=Factorization(coefs[j]);
    list:=[];
    for item in fac do
      int,co:= MonicToIntegral(item[1]);
      Append(~list,<co,int,item[2]>);
    a /:= co^item[2];
    end for;

    str:= str cat Sprintf("(%o)",a);
    for i in [1..#list] do
      str:= str cat Sprintf("*(%o)^%o", list[i,2],list[i,3]);
    end for;
    if j ne 1 then
      str:=str cat Sprintf("*%o",mon[j]);
    end if;
  end for;

  K<nu1>:=BaseRing(BaseRing(f));
  Kx<x>:=PolynomialRing(K);
  Kxt<t>:=PolynomialRing(Kx);

  assert f eq eval(str);
  return str;
end intrinsic;



intrinsic MinimiseL1ToLinearProgram(coefficients::ModMatRngElt, constants::ModMatRngElt) -> LP
  {}/*we turn minimising the function \sum_{i=1..m} | a_{i,1}x_1 + ... + a_{i,n}x_n + b_i |
   into a linear program. The input is coefficients which is an mxn matrix of coefficients a_{i,j}
   and and mx1 matrix of the {b_i}. The output is an equivalent linear program */

  k:=BaseRing(coefficients);
  rows:=Rows(coefficients);
  row_no:=NumberOfRows(coefficients);
  column_no:=NumberOfColumns(coefficients);
  var_no:=row_no+column_no;
 	L := LPProcess(k, var_no);
 	obj:=Matrix(k,1,var_no,[0 : i in [1..column_no]] cat [1 : i in [1..row_no]]);
 	SetObjectiveFunction(L, obj);
  SetIntegerSolutionVariables(L,[ i : i in [1..var_no]], true);


 	for m in [1..row_no] do

    extra_var:=[ 0 : k in [1..row_no-1] ];
    Insert(~extra_var, m, -1);
		lhs1:= Matrix(k,1,var_no, Eltseq(rows[m]) cat extra_var);
		lhs2:= Matrix(k,1,var_no, Eltseq(-rows[m]) cat extra_var);

		rhs1:= Matrix(k,-constants[m]);
		rhs2:= Matrix(k,constants[m]);

		AddConstraints(L, lhs1, rhs1 : Rel := "le");
		AddConstraints(L, lhs2, rhs2 : Rel := "le");

		AddConstraints(L, Matrix(k,1,var_no, [0 : i in [1..column_no]] cat extra_var), Matrix(k,[[0]]) : Rel :="le");
  end for;
  for i in [1..var_no] do  SetLowerBound(L, i, k!-10000); end for;

  return L;
end intrinsic;




intrinsic CoefficientSupport(f::RngMPolElt) -> SeqEnum
  {returns all of the primes ideals with nonzero valuation in the coefficients}
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;
  S := &cat[TrialDivision(Integers()!Norm(Numerator(s))) : s in Coefficients(f) | s ne 0 ]
     cat &cat[TrialDivision(Integers()!Norm(Denominator(s))) : s in Coefficients(f) | s ne 0 ];
  S := SequenceToSet([s[1] : s in S]);
  SS:=&cat[ [pp[1] : pp in Factorization(p*Integers(K))] : p in S ];
  return SS;
end intrinsic;



intrinsic CoefficientValuations(f::RngMPolElt : primes:=CoefficientSupport(f)) -> SeqEnum
  {the valuations of each coefficient at every prime in CoefficientSupport(f)}
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;

  return [ [ Valuation(cc,pp) : cc in Coefficients(ChangeRing(f,K)) ] : pp in primes ];
end intrinsic;


intrinsic IgnorePrime(f::RngMPolElt,pp::RngOrdIdl) -> Any
  {}
  //check if the linear program is already optimal at (0,..,0) for the prime pp.
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;
  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  n:=#variables;
  ZK := Integers(K);
  k:=Integers();
  coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] ];
  mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
  m:=#mexps;
  coefs:=[ K!a[1] : a  in coefs_and_monomials ];
  //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
  obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

  obj := Matrix(k,1,n+1, obj_coefs cat [m]);
  lhs_coefs:= [ A cat [1] : A in mexps ];
  lhs := Matrix(k, lhs_coefs);     //constraints
  rel := Matrix(k,[[1] : ef in mexps]);
  lp_size:=n+1;

  cvals := [ Valuation(c,pp) : c in coefs  ];
  rhs := Matrix(k, [[-cf] : cf in cvals]);          //valuations

  if not(Set([ vv ge 0 : vv in cvals ]) eq Set([true])) then
    ignore_prime:=false;
  else

    zero_constraints:=[];
    nonzero_constraints:=[];
    pp_rhs:=[ Eltseq(r)[1] : r in Rows(rhs) ];

    for i in [1..#lhs_coefs] do
      if pp_rhs[i] eq 0 then
        Append(~zero_constraints, lhs_coefs[i]);
      else
        Append(~nonzero_constraints, lhs_coefs[i]);
      end if;
    end for;

    if zero_constraints eq [] then
      ignore_prime:=false;
    elif nonzero_constraints eq [] then
      ignore_prime:=true;
    else
      zero_angles := [ Arccos(A[lp_size]/Sqrt(&+[ x^2 : x in A ])) : A in zero_constraints ];
      nonzero_angles := [ Arccos(A[lp_size]/Sqrt(&+[ x^2 : x in A ])) : A in nonzero_constraints ];;
      obj_angle:=Arccos((Eltseq(obj)[lp_size])/Sqrt(&+[ x^2 : x in Eltseq(obj) ]));
      zero_angle_range := [ Min(zero_angles), Max(zero_angles) ];
      nonzero_angle_range := [ Min(nonzero_angles), Max(nonzero_angles) ];
      //assert #Set(zero_angle_range) eq 2;

      if (obj_angle gt zero_angle_range[2]) and (obj_angle le nonzero_angle_range[2])
        or (obj_angle lt zero_angle_range[1]) and (obj_angle ge nonzero_angle_range[1]) then
        ignore_prime:=false;
      else
        ignore_prime:=true;
      end if;

      if (obj_angle gt Max(zero_angles cat nonzero_angles))
          or (obj_angle lt Min(zero_angles cat nonzero_angles)) then
            ignore_prime:=true;
      end if;
      //pp; cvals; zero_optimal;
    end if;
  end if;
  return ignore_prime;
end intrinsic;



intrinsic reducemodel_padic(f::RngMPolElt) -> RngMPolElt, SeqEnum
  {Input: a multivariate polynomial f \in K[z_1,..,z_n]; Output: minimal and integral c*f(a_1z_1,...,a_nz_n) and [a_1,...,a_n,c]}
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;
  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  var_size:=#variables;
  ZK := Integers(K);
  k:=RealField(20);
  h:=ClassNumber(K);
  Cl,mp:=ClassGroup(K);
  pm:=Inverse(mp);

  coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] ];
  mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
  m:=#mexps;
  coefs:=[ K!a[1] : a  in coefs_and_monomials ];
  //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;

  //SS:= [ pp : pp in SS | Set([Valuation(cc,pp) : cc in coefs]) notin [{0,1},{0}] ];
  support_init:=CoefficientSupport(f);
  SS:=[];
  for pp in support_init do
    cvals := [ Valuation(c,pp) : c in coefs  ];
    if not((Set(cvals) in [{0,1},{0}]) and (#[ a : a in cvals | a eq 1 ] in [0,1])) then
      Append(~SS,pp);
    end if;
  end for;
  if SS eq [] then
    return f;
  end if;
  //ignore prime not working properly SS:=[ pp : pp in support_init | IgnorePrime(f,pp) eq false ];
  //S is the prime divisors of all norms of numerators and denominators of coeffients

  if h eq 1 then
    lp_size:=(var_size+1)*#SS;
    obj:= Matrix(k,1,lp_size,&cat[ [ Log(Norm(SS[j]))*(&+[ m[i] : m in mexps]) : i in [1..var_size] ] cat [Log(Norm(SS[j]))*m] : j in [1..#SS] ] );
  else
    lp_size:=(var_size+1)*#SS+var_size+1;
    obj:= Matrix(k,1,lp_size,&cat[ [ Log(Norm(SS[j]))*(&+[ m[i] : m in mexps]) : i in [1..var_size] ] cat [Log(Norm(SS[j]))*m] : j in [1..#SS] ] cat [0 : w in [1..var_size+1]]);
  end if;

  L := LPProcess(k, lp_size);
  SetObjectiveFunction(L, obj);
  SetIntegerSolutionVariables(L,[ i : i in [1..lp_size]], true);

  if h eq 1 then
    extra_zeroes:=[ 0 : t in [1..(var_size+1)*(#SS-1)]];
  else
    extra_zeroes:=[ 0 : t in [1..(var_size+1)*(#SS-1)]] cat [ 0 : w in [1..var_size+1] ];
  end if;

  for i in [1..#SS] do
    for j in [1..m] do
      lhs:=Insert(extra_zeroes, (var_size+1)*i-var_size,(var_size+1)*i-var_size-1,mexps[j] cat [1]);
      lhs:=Matrix(k,1,lp_size,lhs);
  		rhs:= Matrix(k,1,1,[-Valuation(coefs[j],SS[i])]);
  		AddConstraints(L, lhs, rhs : Rel := "ge");
    end for;
  end for;

  if h ne 1 then
    for w in [1..var_size+1] do
      //add in the constraints to be principal one variable at a time
      zeroes:= [ 0 : t in [1..var_size] ];
      principal_constraint:=&cat[ Insert(zeroes, w,w-1, [ Eltseq(pm(SS[j]))[1]]) : j in [1..#SS] ];
      principal_constraint:=principal_constraint cat Insert(zeroes, w,w-1, [h]);
      principal_constraint_lhs:=Matrix(k,1,(var_size+1)*(#SS+1),principal_constraint);
      principal_constraint_rhs:=Matrix(k,1,1,[0]);
      AddConstraints(L, principal_constraint_lhs, principal_constraint_rhs : Rel := "eq");
    end for;
  end if;

  for i in [1..lp_size] do  SetLowerBound(L, i, k!-10000); end for;

  soln,state:=Solution(L);
  assert state eq 0;
  soln:=Eltseq(soln);
  soln:= [ Integers()!Round(s) : s in soln ];

  soln_ideals:=<>;
  soln_exponents:=[];
  for r in [1..var_size+1] do
    Append(~soln_exponents, [ soln[(var_size+1)*(j-1)+r] : j in [1..#SS] ] );
    Append(~soln_ideals,&*[ SS[j]^soln[(var_size+1)*(j-1)+r] : j in [1..#SS] ]);
  end for;

  scaling_factors:=<>;
  for aa in soln_ideals do
    tr,a:=IsPrincipal(aa);
    Append(~scaling_factors,a);
  end for;

  guv:=Evaluate(f,[(BaseRing(Parent(f))!scaling_factors[i])*variables[i] : i in [1..var_size]])*BaseRing(Parent(f))!scaling_factors[var_size+1];

  return guv, scaling_factors;
end intrinsic;






intrinsic reducemodel_padic_old(f::RngMPolElt : Integral:=true, ClearDenominators:=false, Minkowski:=true, Speedy:=false) -> RngMPolElt, SeqEnum
  {Input: a multivariate polynomial f \in K[z_1,..,z_n]; Output: minimal and integral c*f(a_1z_1,...,a_nz_n) and [a_1,...,a_n,c]}
  /*Options: Integral, ClearDenominator, Minkowski, Speedy */
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;
  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  n:=#variables;
  ZK := Integers(K);
  k:=Integers();

  if ClearDenominators eq true then
    coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] | Coefficients(f)[i] ne 0 and Exponents(Monomials(f)[i]) ne [0 : k in [1..n]] ];
    mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
    m:=#mexps;
    coefs:=[ K!a[1] : a  in coefs_and_monomials ];
    //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
    obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

    //clear denominators after the fact
    obj := Matrix(k,1,n, obj_coefs);
    lhs_coefs:= mexps;
    lhs := Matrix(k, lhs_coefs);     //constraints
    rel := Matrix(k,[[1] : ef in mexps]);  //lhs greater than rhs
    rescaling_ideals:=[[ 1 : i in [1..n] ]];
    lp_size:=n;
  else
    coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] | Coefficients(f)[i] ne 0 ];
    mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
    m:=#mexps;
    coefs:=[ K!a[1] : a  in coefs_and_monomials ];
    //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
    obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

    //scaling the whole function is baked into the linear program
    obj := Matrix(k,1,n+1, obj_coefs cat [m]);
    lhs_coefs:= [ A cat [1] : A in mexps ];
    lhs := Matrix(k, lhs_coefs);     //constraints
    rel := Matrix(k,[[1] : ef in mexps]);
    rescaling_ideals:=[[ 1 : i in [1..n+1] ]];
    lp_size:=n+1;
  end if;

  new_c := 1;
  new_f:=f;

  SS:=CoefficientSupport(f);
  //S is the prime divisors of all norms of numerators and denominators of coeffients

  minimal_solutions:=[];
  for pp in SS do
    cvals := [ Valuation(c,pp) : c in coefs  ];
    rhs := Matrix(k, [[-cf] : cf in cvals]);          //valuations
    if Integral eq false then
      L:=MinimiseL1ToLinearProgram(lhs, -rhs);
      soln,state:=Solution(L);
      assert state eq 0;
      soln:= [ Eltseq(soln)[i] : i in [1..NumberOfColumns(lhs)] ];
      points_loop:=[soln];

    else

      /*V2:=VectorSpace(Rationals(),2);
      if lp_size eq 2 and Set([ IsIndependent([V2!obj[1],V2!row]) : row in Rows(lhs) ]) eq {true} then

        L := LPProcess(k, lp_size);
        SetObjectiveFunction(L, obj);
        AddConstraints(L, lhs, rhs : Rel := "ge");
        for i in [1..lp_size] do  SetLowerBound(L, i, k!-10000); end for;
        soln,state:=Solution(L);
        assert state eq 0;
        points_loop:=[soln];*/

      //else

      if Speedy eq true then

        L := LPProcess(k, lp_size);
        SetObjectiveFunction(L, obj);
        AddConstraints(L, lhs, rhs : Rel := "ge");
        //UnsetBounds(L) doesn't work
        //These are lower bounds on the solution
        for i in [1..lp_size] do  SetLowerBound(L, i, k!-10000); end for;
        soln,state:=Solution(L);
        points_loop:=[soln];

      else

        //Need to remove the spurious ones that are all zero already
        halfspaces:=[ HalfspaceToPolyhedron(Eltseq(Rows(lhs)[i]),Eltseq(rhs)[i]) : i in [1..#Rows(lhs)] ];
        poly:= &meet[ POL : POL in halfspaces ];
        //find the minimum of the objective function in the region, either using integral vertices or the linear program

        L := LPProcess(k, lp_size);
        SetObjectiveFunction(L, obj);
        AddConstraints(L, lhs, rhs : Rel := "ge");
        //AddConstraints(L, Matrix(k,1,3,[0,1,0]),  Matrix(k,1,1,[0]) : Rel := "eq"); //fix one variables.
        //UnsetBounds(L) doesn't work
        //These are lower bounds on the solution
        for i in [1..lp_size] do SetLowerBound(L, i, k!-10000); end for;
        soln,state:=Solution(L);
        //ProfilePrintByTotalTime(:Max:=40);
        assert state eq 0;
        min:=EvaluateAt(L,soln);

        //Now we intersect our polyhedron with the 'plane of minimal solutions'
        minimal_hyperplane := HyperplaneToPolyhedron(Eltseq(obj),min);
        poly := poly meet minimal_hyperplane;
        //poly := poly meet HyperplaneToPolyhedron([0,1,0],0);
        int_poly := IntegralPart(poly);
        assert IsEmpty(poly) eq false;
        assert IsPolytope(poly);
        min_points:=Setseq(Points(int_poly));
        points_loop:=min_points;
        //all of the points at which the objective function is minimal.
      end if;
      //end if;
    end if;

    Append(~minimal_solutions,points_loop);
    //all triples of ideals to try rescaling by
    rescaling_ideals:=&cat[ [ [ (ideals[i])*(pp^Eltseq(pt)[i]) : i in [1..#Eltseq(pt)] ] : pt in points_loop ] : ideals in rescaling_ideals ];
  end for;
  //for each variable create all possible elements to scale by.

  all_rescalings:=[];
  for vv in rescaling_ideals do
    scaling_factors:= [ ];
    for w in vv do
      aprin, a := IsPrincipal(w);
      if aprin eq false then
        a:=IdealShortVectorsProcess(w, 0, 2: Minkowski:=Minkowski);
      else
        a:=[a];
      end if;
      Append(~scaling_factors,a);
    end for;

    all_lists:=[ [a] : a in scaling_factors[1] ];
    i:=1;
    while i lt lp_size do
      for list in all_lists do
        for elt in scaling_factors[i+1] do
          Append(~all_lists,list cat [elt]);
        end for;
        Exclude(~all_lists,list);
      end for;
      i:=i+1;
    end while;
    assert #all_lists eq &*[ #A : A in scaling_factors ];
    Append(~all_rescalings,all_lists);
  end for;
  all_rescalings:=&cat(all_rescalings);

  new_fuvs:=[];
  for ab in all_rescalings do
    if ClearDenominators eq true then
      guv:=Evaluate(f,[(BaseRing(Parent(f))!ab[i])*variables[i] : i in [1..n]]);
      jj := (ideal<ZK | Coefficients(guv)>)^-1;
      jprinbl, j := IsPrincipal(jj);
      j:=BaseRing(Parent(f))!j;
      if not jprinbl then
        js := IdealShortVectorsProcess(jj, 0, 2: Minkowski:=Minkowski);
      else
        js:=[j];
      end if;
      for j in js do
        guv *:= j;
        Append(~new_fuvs, <#Sprint(guv),guv,ab cat [j]>);
      end for;
    else
      guv:=Evaluate(f,[(BaseRing(Parent(f))!ab[i])*variables[i] : i in [1..n]])*BaseRing(Parent(f))!ab[n+1];
      Append(~new_fuvs, <#Sprint(guv),guv,ab>);
    end if;
    // JV: possibly redundantly, clear denominators one last time
    end for;

  Sort(~new_fuvs);
  new_fuv:=new_fuvs[1,2];
  new_scaling:= new_fuvs[1,3];

  return new_fuv, new_scaling;
end intrinsic;


intrinsic reducemodel_units(f::RngMPolElt : prec:=100) -> RngMPolElt, SeqEnum
  {}
  K := BaseRing(Parent(f));
  //u := Parent(fuv).1;
  //v := Parent(fuv).2;
  ZK := Integers(K);
  r,s:=Signature(K);
  k:=RealField(prec);
  //Rx3<x1,x2,x3>:=PolynomialRing(Rationals(),3);

  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  var_size:=#variables;
  ZK := Integers(K);

  inf_places:=InfinitePlaces(K);
  assert #inf_places eq r+s;
  phi:=function(x);
    return [ Log(Abs(Evaluate(x,v))) : v in inf_places ];
  end function;

  mexps := [ Exponents(m) : m in Monomials(f) ];
  coefs:=Coefficients(f);
  //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;

  UK,mUK:=UnitGroup(K);
  k := RealField(prec);
  UU:= [ K!(mUK(eps)) : eps in Generators(UK) | not(IsFinite(eps)) ];

  if UU eq [] then
    return f, [1: i in [1..var_size+1]];
  else

    constants:=[];
    abs_coef:=[];
  	for n in [1..#mexps] do

      alpha_norm := Log(Abs(Norm(coefs[n])))/(r+s);
      log_coef:= phi(coefs[n]);

  		for m in [1..r+s] do

        if m le r then
          const:= Log(Abs(Evaluate(coefs[n], inf_places[m]))) - Log(Abs(Norm(coefs[n])))/(r+s);
        else
          const:= Log(Abs(Evaluate(coefs[n], inf_places[m]))) - Log(Abs(Norm(coefs[n])))/(2*(r+s));
        end if;
        Append(~constants, [const]);

        etas:= [ phi(eps)[m] : eps in UU ];
        lhs:=&cat[ [ eta*a : a in mexps[n] ] cat [eta] : eta in etas ];
        Append(~abs_coef, lhs);

      end for;
    end for;

    constants:=Matrix(k,constants);
    abs_coef:=Matrix(k,abs_coef);

    L:=MinimiseL1ToLinearProgram(abs_coef, constants);
    //fix_var:=[0,1] cat [0: i in [1..NumberOfVariables(L)-2]]; fix a variable
    //AddConstraints(L, Matrix(k,1,NumberOfVariables(L),fix_var),  Matrix(k,1,1,[0]) : Rel := "eq");

    soln,state:=Solution(L);
    assert state eq 0;
    soln:= [ Eltseq(soln)[i] : i in [1..(var_size+1)*#UU] ];
    soln_rounded:=[ Round(a) : a in soln ];

    eps_soln:= [ &*[ UU[i]^soln_rounded[k*#UU+i] : i in [1..#UU] ] : k in [0..var_size] ];
    assert #eps_soln eq var_size + 1;
    guv:=Evaluate(f,[eps_soln[i]*variables[i] : i in [1..var_size]])*eps_soln[var_size+1];

  	return guv, eps_soln;

  end if;

end intrinsic;



intrinsic padic_LPsolutions(f::RngMPolElt, pp::RngOrdIdl) -> Any
  {}
  if BaseRing(Parent(f)) eq Rationals() then
    K:=RationalsAsNumberField();
  else
    K := BaseRing(Parent(f));
  end if;
  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  n:=#variables;
  ZK := Integers(K);
  k:=Integers();

  coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] | Coefficients(f)[i] ne 0 ];
  mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
  m:=#mexps;
  coefs:=[ K!a[1] : a  in coefs_and_monomials ];
  //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
  obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

  //scaling the whole function is baked into the linear program
  obj := Matrix(k,1,n+1, obj_coefs cat [m]);
  lhs_coefs:= [ A cat [1] : A in mexps ];
  lhs := Matrix(k, lhs_coefs);     //constraints
  rel := Matrix(k,[[1] : ef in mexps]);
  rescaling_ideals:=[[ 1 : i in [1..n+1] ]];
  lp_size:=n+1;


  cvals := [ Valuation(c,pp) : c in coefs  ];
  rhs := Matrix(k, [[-cf] : cf in cvals]);          //valuations

  //Need to remove the spurious ones that are all zero already
  halfspaces:=[ HalfspaceToPolyhedron(Eltseq(Rows(lhs)[i]),Eltseq(rhs)[i]) : i in [1..#Rows(lhs)] ];
  poly:= &meet[ POL : POL in halfspaces ];
  //find the minimum of the objective function in the region, either using integral vertices or the linear program

  L := LPProcess(k, lp_size);
  SetObjectiveFunction(L, obj);
  AddConstraints(L, lhs, rhs : Rel := "ge");
  //AddConstraints(L, Matrix(k,1,3,[0,1,0]),  Matrix(k,1,1,[0]) : Rel := "eq"); //fix one variables.
  //UnsetBounds(L) doesn't work
  //These are lower bounds on the solution
  for i in [1..lp_size] do SetLowerBound(L, i, k!-10000); end for;
  soln,state:=Solution(L);
  //ProfilePrintByTotalTime(:Max:=40);
  assert state eq 0;
  min:=EvaluateAt(L,soln);

  //Now we intersect our polyhedron with the 'plane of minimal solutions'
  minimal_hyperplane := HyperplaneToPolyhedron(Eltseq(obj),min);
  poly := poly meet minimal_hyperplane;
  //poly := poly meet HyperplaneToPolyhedron([0,1,0],0);
  int_poly := IntegralPart(poly);
  assert IsEmpty(poly) eq false;
  assert IsPolytope(poly);
  min_points:=Setseq(Points(int_poly));

  solns:= [ Eltseq(A) : A in min_points ];
  return solns;
  //all of the points at which the objective function is minimal.

end intrinsic;


/*
L1Sum:=function(f)
   /*Evaluate H(x_1,..,x_n) = \sum_{i=1..m} | a_{i,1}x_1 + ... + a_{i,n}x_n + b_i | at the point
   The input is coefficients which is an mxn matrix of coefficients a_{i,j}
   and and mx1 matrix of the {b_i}.
   K := BaseRing(Parent(f));
   //u := Parent(fuv).1;
   //v := Parent(fuv).2;
   ZK := Integers(K);
   r,s:=Signature(K);
   k:=RealField(prec);
   //Rx3<x1,x2,x3>:=PolynomialRing(Rationals(),3);

   variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
   var_size:=#variables;
   ZK := Integers(K);

   inf_places:=InfinitePlaces(K);
   assert #inf_places eq r+s;
   phi:=function(x);
     return [ Log(Abs(Evaluate(x,v))) : v in inf_places ];
   end function;

   mexps := [ Exponents(m) : m in Monomials(f) ];
   coefs:=Coefficients(f);
   &+[ ]
   //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;

   UK,mUK:=UnitGroup(K);
   k := RealField(prec);
   UU:= [ K!(mUK(eps)) : eps in Generators(UK) | not(IsFinite(eps)) ];

   if UU eq [] then
     return "no units";
   else

     constants:=[];
     abs_coef:=[];
   	for n in [1..#mexps] do

       alpha_norm := Log(Abs(Norm(coefs[n])))/(r+s);
       log_coef:= phi(coefs[n]);

   		for m in [1..r+s] do

         const:= Log(Abs(Evaluate(coefs[n], inf_places[m]))) - Log(Abs(Norm(coefs[n])))/(r+s);
         Append(~constants, [const]);

         etas:= [ phi(eps)[m] : eps in UU ];
         lhs:=&cat[ [ eta*a : a in mexps[n] ] cat [eta] : eta in etas ];
         Append(~abs_coef, lhs);

       end for;
     end for;
    end if;

    constants:=Matrix(k,constants);
    abs_coef:=Matrix(k,abs_coef);

  rows_coef:=Rows(abs_coef);
  rows_const:=Rows(constants);

  return &+[ Abs( &+[ Eltseq(rows_coef[j])[i]*point[i] : i in [1..#point] ] + Eltseq(rows_const[j])[1] ) : j in [1..#rows_coef] ];
end function; */



intrinsic IdealShortVectorsProcess(I::RngOrdFracIdl, l::RngIntElt, u::RngIntElt : Minkowski:=true, timeout:=2) -> SeqEnum
  {Given an ideal I, thought of as a lattice, and integers l and u, return vectors in the lattice bounded by l and u scaled by a medium sized vector in parallelepiped.}
  //l,u are size in which to search over lattice, scaled by a medium sized vector in parallelepiped.
  if Degree(NumberField(Order(I))) gt 1 then
    if Minkowski eq true then
      Ibasis:=Basis(I);
      IxDen := Order(I)!!(I*Denominator(I));
      IxDen_gens,mxDen:=MinkowskiLattice(IxDen);
      Igens:=IxDen_gens/Denominator(I);
      BI:=Basis(Igens);
      dimL:=#BI;
      prec:=100+6*dimL;
      Rprec:=RealField(prec);
      VS:=VectorSpace(Rprec,dimL);
      BI_gens:=[ [ Rprec!v : v in Eltseq(gen) ] : gen in BI ];

      while Dimension(sub< VS | BI_gens >) lt dimL do
        prec:=prec+20;
        Rprec:=RealField(prec);
        VS:=VectorSpace(Rprec,dimL);
        BI_gens:=[ [ Rprec!v : v in Eltseq(gen) ] : gen in BI ];
      end while;

      LWB:=LatticeWithBasis(RMatrixSpace(Rprec,dimL,dimL)!&cat(BI_gens)); //lower the precision for efficiency
      OLWB:=LWB; // save original lattice in case wanted
      LWB:=CoordinateLattice(LWB);
      min_vec:=Min(LWB);
      avg_vec:=Determinant(LWB)^(1/(dimL));
      //EC:=EnumerationCost(LWB20, 10*Sqrt(avg_vec));
      if l eq 0 then l +:= Rprec!10^(-prec); end if;
      SVP:=ShortVectorsProcess(LWB, avg_vec*l, avg_vec*u);

      SV:=[];
      while not(IsEmpty(SVP)) do
        Append(~SV, NextVector(SVP));
      end while;

      t:=Realtime(); //set a timeout
      SVcoord :=[];
      for w in SV do
        Append(~SVcoord, [ Round(c) : c in Eltseq(w) ]);
        if Realtime(t) gt timeout then
          break;
        end if;
      end for;

      SIelts := [ &+[w[i]*Ibasis[i] : i in [1..#Ibasis]] : w in SVcoord ];
      //assert something to make sure there was no precision error
      return SIelts;

    else
      Igens := LLLBasis(I);
      // assert [ A/Denominator(I) : A in LLLBasis(I*Denominator(I)) ] eq Igens;
      Zn :=StandardLattice(#Igens);
      if l eq 0 then l := 1; end if;  // integral lattice, so
      SVP:=ShortVectorsProcess(Zn, Ceiling(l),Ceiling(u));
      SV:=[];
      while not(IsEmpty(SVP)) do
        Append(~SV, NextVector(SVP));
      end while;
      MM := [ Eltseq(w) : w in SV ];
      SIelts:=[ (&+[ M[i]*Igens[i] : i in [1..#Igens] ]) : M in MM ] cat [1];
      return SIelts;
    end if;

  else
    tr, I_pr:=IsPrincipal(I);
    return [I_pr];
  end if;
end intrinsic;
