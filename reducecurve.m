SetClassGroupBounds("GRH");

intrinsic IdealShortVectorsProcess(I::RngOrdFracIdl, l::RngIntElt, u::RngIntElt : Minkowski:=true, timeout:=2) -> SeqEnum
  {Given an ideal I, thought of as a lattice, and integers l and u, return vectors in the lattice bounded by l and u scaled by a medium sized vector in parallelepiped.}
  //l,u are size in which to search over lattice, scaled by a medium sized vector in parallelepiped.
  if Degree(NumberField(Order(I))) gt 1 then
    if Minkowski eq true then
      Ibasis:=Basis(I);
      IxDen := Order(I)!!(I*Denominator(I));
      IxDen_gens,mxDen:=MinkowskiLattice(IxDen);
      Igens:=IxDen_gens/Denominator(I);
      BI:=Basis(Igens);
      dimL:=#BI;
      prec:=100+6*dimL;
      Rprec:=RealField(prec);
      VS:=VectorSpace(Rprec,dimL);
      BI_gens:=[ [ Rprec!v : v in Eltseq(gen) ] : gen in BI ];

      while Dimension(sub< VS | BI_gens >) lt dimL do
        prec:=prec+20;
        Rprec:=RealField(prec);
        VS:=VectorSpace(Rprec,dimL);
        BI_gens:=[ [ Rprec!v : v in Eltseq(gen) ] : gen in BI ];
      end while;

      LWB:=LatticeWithBasis(RMatrixSpace(Rprec,dimL,dimL)!&cat(BI_gens)); //lower the precision for efficiency
      OLWB:=LWB; // save original lattice in case wanted
      LWB:=CoordinateLattice(LWB);
      min_vec:=Min(LWB);
      avg_vec:=Determinant(LWB)^(1/(dimL));
      //EC:=EnumerationCost(LWB20, 10*Sqrt(avg_vec));
      if l eq 0 then l +:= Rprec!10^(-prec); end if;
      SVP:=ShortVectorsProcess(LWB, avg_vec*l, avg_vec*u);

      SV:=[];
      while not(IsEmpty(SVP)) do
        Append(~SV, NextVector(SVP));
      end while;

      t:=Realtime(); //set a timeout
      SVcoord :=[];
      for w in SV do
        Append(~SVcoord, [ Round(c) : c in Eltseq(w) ]);
        if Realtime(t) gt timeout then
          break;
        end if;
      end for;

      SIelts := [ &+[w[i]*Ibasis[i] : i in [1..#Ibasis]] : w in SVcoord ];
      //assert something to make sure there was no precision error
      return SIelts;

    else
      Igens := LLLBasis(I);
      // assert [ A/Denominator(I) : A in LLLBasis(I*Denominator(I)) ] eq Igens;
      Zn :=StandardLattice(#Igens);
      if l eq 0 then l := 1; end if;  // integral lattice, so
      SVP:=ShortVectorsProcess(Zn, Ceiling(l),Ceiling(u));
      SV:=[];
      while not(IsEmpty(SVP)) do
        Append(~SV, NextVector(SVP));
      end while;
      MM := [ Eltseq(w) : w in SV ];
      SIelts:=[ (&+[ M[i]*Igens[i] : i in [1..#Igens] ]) : M in MM ] cat [1];
      return SIelts;
    end if;

  else
    tr, I_pr:=IsPrincipal(I);
    return [I_pr];
  end if;
end intrinsic;

intrinsic SmallFunctions(Qs::SeqEnum[PlcCrvElt], d::RngIntElt) -> SeqEnum
  {Given a sequence of points Qs, return functions supported on Qs of degree <= d}
  // Qs, points which are "small"
  // d, a degree bound; what d does genus 2 need?
  // Output: functions supported on {Qs} of degree <= d

  //The "small" points are the support of phi, phi-1.
  //sort "small" points by degree
  Qs := Sort(Qs, func<Q,R | Degree(Q)-Degree(R)>);
  Ds := [];
  QDs := [Divisor(Q) : Q in Qs]; //Make the points into divisors
  newDs := [Universe(QDs) | 0];

  //add divisors so that degree is <= d and collect in Ds
  while #newDs ne 0 do
    frontierDs := [];
    for newD in newDs do
      dnewD := Degree(newD);
      for RD in QDs do
        if Degree(RD) + dnewD le d then
          Append(~Ds, RD + newD);
          Append(~frontierDs, RD + newD);
        end if;
      end for;
    end for;
    newDs := frontierDs;
  end while;
  Ds:=Setseq(Set(Ds));

  xs := [];
  for Dden in Ds do
    for Dnum in Ds do

      D := Dden-Dnum;
      if D eq Parent(D)!0 then continue; end if;
      RR, mRR := RiemannRochSpace(D);
      if Dimension(RR) eq 1 then
        x := mRR(RR.1);
        if Divisor(x) ne Parent(Divisor(x))!0 then
          Append(~xs, x);
        end if;
      end if;
    end for;
  end for;
  //looks like every x appears twice
  return Setseq(Set(xs));
  //functions supported on the points of small degree as
  //generated by the Riemann Roch space
end intrinsic;

//What is the difference in size from a divisor D and -D?
//Whats the relationship between the size of the places, the multiplicity and the size of f?

intrinsic model(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {Given a Belyi map phi and a rational function x_op, find a plane model for the curve with phi and x_op as coordinates}
  //add 1/phi etc in here.
  fu := MinimalPolynomial(phi);
  fv := MinimalPolynomial(x_op);
  K := BaseRing(BaseRing(Parent(phi)));
  Kuvz<vz,uz,z> := PolynomialRing(K, 3);
  _<vf,uf,zf> := FieldOfFractions(Kuvz);

  fues := Eltseq(fu);
  fves := Eltseq(fv);
  fu := Numerator(&+[Evaluate(fues[i],zf)*uf^(i-1) : i in [1..#fues]]);
  fv := Numerator(&+[Evaluate(fves[i],zf)*vf^(i-1) : i in [1..#fves]]);

  fuv := Resultant(fu,fv,z);
  //groebner basis? 1/phi here etc
  /*
  _<u> := PolynomialRing(K);
  _<v> := PolynomialRing(Parent(u));
  cuv := Coefficients(fuv);
  muv := Monomials(fuv);
  return &+[cuv[i]*Evaluate(muv[i],[v,u,0]) : i in [1..#cuv]];
  */
  fuvFact := Factorization(fuv);
  if #fuvFact gt 1 then
    for j := 1 to #fuvFact do
      if Evaluate(fuvFact[j][1], [x_op, phi,0]) eq 0 then
        fuv := fuvFact[j][1];
        assert &and[Evaluate(fuvFact[k][1], [x_op, phi,0]) ne 0 : k in [j+1..#fuvFact]];
      end if;
    end for;
  end if;
  //_<u,v> := PolynomialRing(K,2);
  //return Evaluate(fuv,[v,u,0]);
  _<t,x> := PolynomialRing(K,2);
  f_plane:=Evaluate(fuv,[x,t,0]);
  //f_univ:=MultivariateToUnivariate(f_unit);
  //f_display:=PolynomialToFactoredString(f_univ);
  return f_plane;
  //x=v, t=u
end intrinsic;

intrinsic ReduceModel(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {}
  f_plane:=model(phi,x_op);
  f_padic := reducemodel_padic(f_plane);
  f_unit := reducemodel_units(f_padic);
  return f_unit;
end intrinsic;

intrinsic PlaneModel(phi::FldFunFracSchElt, x_op::FldFunFracSchElt) -> RngMPolElt
  {}
  return model(phi,x_op);
end intrinsic;

// copy-pasta-ed from BelyiDB's LLL.m
function PlaneModelGroebner(phi, x_op)
  //{Given a Belyi map phi, return a plane model for its domain such that t is the Belyi map}
  KC := Parent(phi);
  C := Curve(KC);
  K := BaseRing(C);
  nu := K.1;
  phi0 := Numerator(phi);
  phioo := Denominator(phi);
  x_op0 := Numerator(x_op);
  x_opoo := Denominator(x_op);
  if Genus(C) eq 0 then // defined on PP^1, so no curve equation
    R<X,Phi,X_op,u,v> := PolynomialRing(K,5);
    h := hom< KC -> R | [X]>;
    I := ideal< R | h(phioo)*Phi - h(phi0), h(x_opoo)*X_op - h(x_op0), v*h(phioo) - 1, u*h(x_opoo) - 1>; // need last equations to avoid points where phioo = 0
    // eliminate v to obtain plane equation
    basis := Basis(EliminationIdeal(I,{X_op,Phi}));
    assert #basis eq 1;
    new_eqn := basis[1];
    S<x,t> := PolynomialRing(K,2);
    h_plane := hom< Parent(new_eqn) -> S | [x,t,0,0,0] >;
  else // so the curve actually has an equation
    KC<x,y> := KC;
    R<X,Y,Phi,X_op,u,v> := PolynomialRing(K,6);
    h := hom< KC -> R | [X,Y]>;
    curve_eqn := DefiningEquation(AffinePatch(C,1));
    h_curve := hom< Parent(curve_eqn) -> R | [X,Y] >;
    // need last equation to avoid points where phioo = 0
    I := ideal< R | h_curve(curve_eqn), h(phioo)*Phi - h(phi0), h(x_opoo)*X_op - h(x_op0), v*h(phioo) - 1, u*h(x_opoo) - 1>; // need last equations to avoid points where phioo = 0
    // eliminate X and v to obtain plane equation
    basis := Basis(EliminationIdeal(I,{X_op,Phi}));
    assert #basis eq 1;
    new_eqn := basis[1];
    printf "new equation = %o\n", new_eqn;
    S<x,t> := PolynomialRing(K,2);
    h_plane := hom< Parent(new_eqn) -> S | [0,0,t,x,0,0] >;
    //h_plane := hom< Parent(new_eqn) -> S | X_op :-> x, Phi :-> t, X :-> 0, Y :-> 0, u :-> 0, v :-> 0 >;
  end if;
  return h_plane(new_eqn);
end function;

intrinsic CoefficientValuationsSum(f::., pp::.) -> Any
  {}
  return &+[ Valuation(a,pp) : a in Coefficients(f) ], [ Valuation(a,pp) : a in Coefficients(f) ];
end intrinsic;

intrinsic BelyiObjectiveFunction(fuv::RngMPolElt) -> RngMPolElt
  {Given a polynomial or rational function fuv in 2 variables, return...?} // TODO: finish doc string
  K := BaseRing(Parent(fuv));
  u := Parent(fuv).1;
  v := Parent(fuv).2;
  Rx3<x1,x2,x3>:=PolynomialRing(Rationals(),3);
  mexps := [ Exponents(m) : m in Monomials(fuv) ];
  coefs:=Coefficients(fuv);
  assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
  return (&+[ m[1] : m in mexps])*x1 + (&+[ m[2] : m in mexps])*x2 + #mexps*x3;
end intrinsic;


intrinsic MultivariateToUnivariate(f::RngMPolElt) -> RngUPolElt
  {turns an element f in K[x,t] into an element K[x][t]}

  fstring:=Sprint(f);
  K<nu1> := BaseRing(Parent(f));
  Kx<x>:=PolynomialRing(K);
  Kxt<t>:=PolynomialRing(Kx);
  return eval(fstring);
end intrinsic;

intrinsic MonicToIntegral(f::RngUPolElt : Minkowski := true) -> Any
  {scale the monic univariate polynomial to be integral}
  assert IsMonic(f);
  K:=BaseRing(Parent(f));
  ZK:=Integers(K);
  coefs:=[ a : a in Coefficients(f) | a ne 0 ];

  aa := ideal<ZK | coefs>^-1;
  aprin, a := IsPrincipal(aa);
  if aprin eq false then
    a:=IdealShortVectorsProcess(aa, 0, 2: Minkowski:=Minkowski)[1];
  end if;
  f_new:=f*a;

  return f_new, a;
end intrinsic;

intrinsic PolynomialToFactoredString(f::RngUPolElt) -> MonStgElt
  {factorise the polynomial f and return it as a string. Needs to be a multivariate polynomial in K[x][t]}

  coefs:=Coefficients(f);
  mon:=Monomials(f);
  str:="";
  for j in [1..#coefs] do
    if j ne 1 then
      str:=str cat " + ";
    end if;
    a:=LeadingCoefficient(coefs[j]);
    fac:=Factorization(coefs[j]);
    list:=[];
    for item in fac do
      int,co:= MonicToIntegral(item[1]);
      Append(~list,<co,int,item[2]>);
    a /:= co^item[2];
    end for;

    str:= str cat Sprintf("(%o)",a);
    for i in [1..#list] do
      str:= str cat Sprintf("*(%o)^%o", list[i,2],list[i,3]);
    end for;
    if j ne 1 then
      str:=str cat Sprintf("*%o",mon[j]);
    end if;
  end for;

  K<nu1>:=BaseRing(BaseRing(f));
  Kx<x>:=PolynomialRing(K);
  Kxt<t>:=PolynomialRing(Kx);

  assert f eq eval(str);
  return str;
end intrinsic;



intrinsic MinimiseL1ToLinearProgram(coefficients::ModMatRngElt, constants::ModMatRngElt) -> LP
  {}/*we turn minimising the function \sum_{i=1..m} | a_{i,1}x_1 + ... + a_{i,n}x_n + b_i |
   into a linear program. The input is coefficients which is an mxn matrix of coefficients a_{i,j}
   and and mx1 matrix of the {b_i}. The output is an equivalent linear program */

  k:=BaseRing(coefficients);
  rows:=Rows(coefficients);
  row_no:=NumberOfRows(coefficients);
  column_no:=NumberOfColumns(coefficients);
  var_no:=row_no+column_no;
 	L := LPProcess(k, var_no);
 	obj:=Matrix(k,1,var_no,[0 : i in [1..column_no]] cat [1 : i in [1..row_no]]);
 	SetObjectiveFunction(L, obj);


 	for m in [1..row_no] do

    extra_var:=[ 0 : k in [1..row_no-1] ];
    Insert(~extra_var, m, -1);
		lhs1:= Matrix(k,1,var_no, Eltseq(rows[m]) cat extra_var);
		lhs2:= Matrix(k,1,var_no, Eltseq(-rows[m]) cat extra_var);

		rhs1:= Matrix(k,-constants[m]);
		rhs2:= Matrix(k,constants[m]);

		AddConstraints(L, lhs1, rhs1 : Rel := "le");
		AddConstraints(L, lhs2, rhs2 : Rel := "le");

		AddConstraints(L, Matrix(k,1,var_no, [0 : i in [1..column_no]] cat extra_var), Matrix(k,[[0]]) : Rel :="le");
  end for;
  for i in [1..var_no] do  SetLowerBound(L, i, k!-10000); end for;

  return L;
end intrinsic;


intrinsic CoefficientSupport(f::RngMPolElt) -> SeqEnum
  {returns all of the primes ideals with nonzero valuation in the coefficients}
  K:=BaseRing(Parent(f));
  S := &cat[TrialDivision(Integers()!Norm(Numerator(s))) : s in Coefficients(f) | s ne 0 ]
     cat &cat[TrialDivision(Integers()!Norm(Denominator(s))) : s in Coefficients(f) | s ne 0 ];
  S := SequenceToSet([s[1] : s in S]);
  SS:=&cat[ [pp[1] : pp in Factorization(p*Integers(K))] : p in S ];
  return SS;
end intrinsic;


intrinsic CoefficientValuations(f::RngMPolElt) -> SeqEnum
  {the valuations of each coefficient at every prime in CoefficientSupport(f)}
  return [ [ Valuation(cc,pp) : cc in Coefficients(f) ] : pp in CoefficientSupport(f) ];
end intrinsic;


intrinsic reducemodel_padic(f::RngMPolElt : Integral:=true, ClearDenominators:=true, Minkowski:=true, Speedy:=false) -> RngMPolElt, SeqEnum
  {Input: a multivariate polynomial f \in K[z_1,..,z_n]; Output: minimal and integral c*f(a_1z_1,...,a_nz_n) and [a_1,...,a_n,c]}
  K := BaseRing(Parent(f));
  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  n:=#variables;
  ZK := Integers(K);
  k:=Integers();

  if ClearDenominators eq true then
    coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] | Coefficients(f)[i] ne 0 and Exponents(Monomials(f)[i]) ne [0 : k in [1..n]] ];
    mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
    m:=#mexps;
    coefs:=[ K!a[1] : a  in coefs_and_monomials ];
    //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
    obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

    //clear denominators after the fact
    obj := Matrix(k,1,n, obj_coefs);
    lhs_coefs:= mexps;
    lhs := Matrix(k, lhs_coefs);     //constraints
    rel := Matrix(k,[[1] : ef in mexps]);  //lhs greater than rhs
    rescaling_ideals:=[[ 1*ZK : i in [1..n] ]];
    lp_size:=n;
  else
    coefs_and_monomials:= [ [Coefficients(f)[i],Monomials(f)[i]] : i in [1..#Coefficients(f)] | Coefficients(f)[i] ne 0 ];
    mexps := [ Exponents(m[2]) : m in coefs_and_monomials ];
    m:=#mexps;
    coefs:=[ K!a[1] : a  in coefs_and_monomials ];
    //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;
    obj_coefs:= [ &+[ m[i] : m in mexps] : i in [1..n] ];

    //scaling the whole function is baked into the linear program
    obj := Matrix(k,1,n+1, obj_coefs cat [m]);
    lhs_coefs:= [ A cat [1] : A in mexps ];
    lhs := Matrix(k, lhs_coefs);     //constraints
    rel := Matrix(k,[[1] : ef in mexps]);
    rescaling_ideals:=[[ 1*ZK : i in [1..n+1] ]];
    lp_size:=n+1;
  end if;

  new_c := 1;
  new_f:=f;

  SS:=CoefficientSupport(f);
  //S is the prime divisors of all norms of numerators and denominators of coeffients
  minimal_solutions:=[];

  for pp in SS do

	  cvals := [ Valuation(c,pp) : c in coefs  ];
    rhs := Matrix(k, [[-cf] : cf in cvals]);          //valuations

    if Set(cvals) ne Set([0]) then
      //decide if solution is going to be (0,0,0)
      if Integral eq false then
        L:=MinimiseL1ToLinearProgram(lhs, -rhs);
        soln,state:=Solution(L);
        assert state eq 0;
        soln:= [ Eltseq(soln)[i] : i in [1..NumberOfColumns(lhs)] ];
        points_loop:=[soln];

      else

        /*V2:=VectorSpace(Rationals(),2);
        if lp_size eq 2 and Set([ IsIndependent([V2!obj[1],V2!row]) : row in Rows(lhs) ]) eq {true} then

          L := LPProcess(k, lp_size);
          SetObjectiveFunction(L, obj);
          AddConstraints(L, lhs, rhs : Rel := "ge");
          for i in [1..lp_size] do  SetLowerBound(L, i, k!-10000); end for;
          soln,state:=Solution(L);
          assert state eq 0;
          points_loop:=[soln];*/

        //else

        if Speedy eq true then

          L := LPProcess(k, lp_size);
          SetObjectiveFunction(L, obj);
          AddConstraints(L, lhs, rhs : Rel := "ge");
          //UnsetBounds(L) doesn't work
          //These are lower bounds on the solution
          for i in [1..lp_size] do  SetLowerBound(L, i, k!-10000); end for;
          soln,state:=Solution(L);
          points_loop:=[soln];

        else

          //Need to remove the spurious ones that are all zero already
          halfspaces:=[ HalfspaceToPolyhedron(Eltseq(Rows(lhs)[i]),Eltseq(rhs)[i]) : i in [1..#Rows(lhs)] ];
          poly:= &meet[ POL : POL in halfspaces ];
          //find the minimum of the objective function in the region, either using integral vertices or the linear program

          L := LPProcess(k, lp_size);
          SetObjectiveFunction(L, obj);
          AddConstraints(L, lhs, rhs : Rel := "ge");
          //AddConstraints(L, Matrix(k,1,3,[0,1,0]),  Matrix(k,1,1,[0]) : Rel := "eq"); //fix one variables.
          //UnsetBounds(L) doesn't work
          //These are lower bounds on the solution
          for i in [1..lp_size] do SetLowerBound(L, i, k!-10000); end for;
          soln,state:=Solution(L);
          //ProfilePrintByTotalTime(:Max:=40);
          assert state eq 0;
          min:=EvaluateAt(L,soln);

          //Now we intersect our polyhedron with the 'plane of minimal solutions'
          minimal_hyperplane := HyperplaneToPolyhedron(Eltseq(obj),min);
          poly := poly meet minimal_hyperplane;
          //poly := poly meet HyperplaneToPolyhedron([0,1,0],0);
          int_poly := IntegralPart(poly);
          assert IsEmpty(poly) eq false;
          assert IsPolytope(poly);
          min_points:=Setseq(Points(int_poly));
          points_loop:=min_points;
          //all of the points at which the objective function is minimal.
        end if;
        //end if;
      end if;

      Append(~minimal_solutions,points_loop);
      //all triples of ideals to try rescaling by
      rescaling_ideals:=&cat[ [ [ (ideals[i])*(pp^Eltseq(pt)[i]) : i in [1..#Eltseq(pt)] ] : pt in points_loop ] : ideals in rescaling_ideals ];
    end if;
  end for;

  Cl,mp:=ClassGroup(K);
  if Order(Cl) ne 1 then
    cl_gen:=Cl.1;
  end if;

  all_rescalings:=[];
  for vv in rescaling_ideals do
    scaling_factors:=[];
    for aa in vv do
      Inverse(mp)(aa);
      principalize:=mp(-Inverse(mp)(aa)); //make sure this is positive exponent
      id:=aa*principalize;
      aprin,a:=IsPrincipal(id);
      assert aprin;
      Append(~scaling_factors,a);
    end for;
    Append(~all_rescalings,scaling_factors);
  end for;
  //for each variable create all possible elements to scale by.

/*  all_rescalings:=[];
  for vv in rescaling_ideals do
    scaling_factors:= [ ];
    for w in vv do
      aprin, a := IsPrincipal(w);
      if aprin eq false then
        a:=IdealShortVectorsProcess(w, 0, 2: Minkowski:=Minkowski);
      else
        a:=[a];
      end if;
      Append(~scaling_factors,a);
    end for;

    all_lists:=[ [a] : a in scaling_factors[1] ];
    i:=1;
    while i lt lp_size do
      for list in all_lists do
        for elt in scaling_factors[i+1] do
          Append(~all_lists,list cat [elt]);
        end for;
        Exclude(~all_lists,list);
      end for;
      i:=i+1;
    end while;
    assert #all_lists eq &*[ #A : A in scaling_factors ];
    Append(~all_rescalings,all_lists);
  end for;
  all_rescalings:=&cat(all_rescalings);*/

  new_fuvs:=[];
  for ab in all_rescalings do
    if ClearDenominators eq true then
      guv:=Evaluate(f,[ab[i]*variables[i] : i in [1..n]]);
    else
      guv:=Evaluate(f,[ab[i]*variables[i] : i in [1..n]])*ab[n+1];
    end if;
    // JV: possibly redundantly, clear denominators one last time
    jj := (ideal<ZK | Coefficients(guv)>)^-1;
    jprinbl, j := IsPrincipal(jj);
    if not jprinbl then
      js := IdealShortVectorsProcess(jj, 0, 2: Minkowski:=Minkowski);
    else
      js:=[j];
    end if;

    for j in js do
      guv *:= j;
      if ClearDenominators eq true then
        Append(~new_fuvs, <#Sprint(guv),guv,ab cat [j]>);
      else
        cd:=ab;
        c:=cd[n+1]; Prune(~cd);
        Append(~cd,c*j);
        Append(~new_fuvs, <#Sprint(guv),guv,cd>);
      end if;
    end for;
  end for;

  Sort(~new_fuvs);
  new_fuv:=new_fuvs[1,2];
  new_scaling:= new_fuvs[1,3];

  return new_fuv, new_scaling;
end intrinsic;


intrinsic reducemodel_units(f::RngMPolElt : prec:=100) -> RngMPolElt, SeqEnum
  {}
  K := BaseRing(Parent(f));
  //u := Parent(fuv).1;
  //v := Parent(fuv).2;
  ZK := Integers(K);
  r,s:=Signature(K);
  k:=Integers();
  //Rx3<x1,x2,x3>:=PolynomialRing(Rationals(),3);

  variables:=[ Parent(f).i : i in [1..#Names(Parent(f))] ];
  var_size:=#variables;
  ZK := Integers(K);
  k:=Integers();

  inf_places:=InfinitePlaces(K);
  assert #inf_places eq r+s;
  phi:=function(x);
    return [ Log(Abs(Evaluate(x,v))) : v in inf_places ];
  end function;

  mexps := [ Exponents(m) : m in Monomials(f) ];
  coefs:=Coefficients(f);
  //assert &+[ coefs[i]*(u^mexps[i,1])*v^mexps[i,2] : i in [1..#mexps] ] eq fuv;

  UK,mUK:=UnitGroup(K);
  k1 := RealField(prec);
  UU:= [ K!(mUK(eps)) : eps in Generators(UK) | not(IsFinite(eps)) ];

  if UU eq [] then
    return f, [1: i in [1..var_size+1]];
  else

    constants:=[];
    abs_coef:=[];
  	for n in [1..#mexps] do

      alpha_norm := Log(Abs(Norm(coefs[n])))/(r+s);
      log_coef:= phi(coefs[n]);

  		for m in [1..r+s] do

        const:= Log(Abs(Evaluate(coefs[n], inf_places[m]))) - Log(Abs(Norm(coefs[n])))/(r+s);
        Append(~constants, [const]);

        etas:= [ phi(eps)[m] : eps in UU ];
        lhs:=&cat[ [ eta*a : a in mexps[n] ] cat [eta] : eta in etas ];
        Append(~abs_coef, lhs);

      end for;
    end for;

    constants:=Matrix(k1,constants);
    abs_coef:=Matrix(k1,abs_coef);

    L:=MinimiseL1ToLinearProgram(abs_coef, constants);
    //fix_var:=[0,1] cat [0: i in [1..NumberOfVariables(L)-2]]; fix a variable
    //AddConstraints(L, Matrix(k1,1,NumberOfVariables(L),fix_var),  Matrix(k1,1,1,[0]) : Rel := "eq");

    soln,state:=Solution(L);
    assert state eq 0;
    soln:= [ Eltseq(soln)[i] : i in [1..(var_size+1)*#UU] ];
    soln_rounded:=[ Round(a) : a in soln ];

    eps_soln:= [ &*[ UU[i]^soln_rounded[k*#UU+i] : i in [1..#UU] ] : k in [0..var_size] ];
    assert #eps_soln eq var_size + 1;
    guv:=Evaluate(f,[eps_soln[i]*variables[i] : i in [1..var_size]])*eps_soln[var_size+1];

  	return guv, eps_soln;

  end if;

end intrinsic;
